# -*- coding: utf-8 -*-
"""CNN_Project_Venugopal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zd5zpeCaRZUtrl2SkgUQ-F3bUIqXbzal
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from sklearn.model_selection import KFold
from sklearn.metrics import confusion_matrix, accuracy_score
import matplotlib.pyplot as plt
import seaborn as sns

# Load the MNIST dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Preprocess the data
x_train = x_train.reshape(-1, 28, 28, 1).astype('float32') / 255.0
x_test = x_test.reshape(-1, 28, 28, 1).astype('float32') / 255.0

# Define the CNN architecture
def create_model():
    model = Sequential([
        Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
        MaxPooling2D((2, 2)),
        Conv2D(64, (3, 3), activation='relu'),
        MaxPooling2D((2, 2)),
        Conv2D(64, (3, 3), activation='relu'),
        Flatten(),
        Dense(64, activation='relu'),
        Dense(10, activation='softmax')
    ])
    return model

# Define K-Fold cross-validation
kfold = KFold(n_splits=5, shuffle=True)

fold = 0
accuracies = []
conf_matrices = []

for train_idx, val_idx in kfold.split(x_train):
    fold += 1
    print(f"Fold {fold}:")

    # Split data into training and validation sets
    x_fold_train, x_fold_val = x_train[train_idx], x_train[val_idx]
    y_fold_train, y_fold_val = y_train[train_idx], y_train[val_idx]

    class_labels = [str(i) for i in range(10)]

    # Create and compile the model
    model = create_model()
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train the model
    history = model.fit(x_fold_train, y_fold_train, epochs=5, batch_size=64, validation_data=(x_fold_val, y_fold_val), verbose=1)

    # Evaluate the model
    _, accuracy = model.evaluate(x_test, y_test, verbose=0)
    accuracies.append(accuracy)
    print(f"Test Accuracy for Fold {fold}: {accuracy}")

    # Confusion Matrix
    y_pred = np.argmax(model.predict(x_test), axis=-1)
    conf_matrix = confusion_matrix(y_test, y_pred)
    conf_matrices.append(conf_matrix)
    print("Confusion Matrix:")
    print(conf_matrix)
    plt.figure(figsize=(8, 6))
    sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues", xticklabels=class_labels, yticklabels=class_labels)
    plt.xlabel("Predicted")
    plt.ylabel("True")
    plt.title("Confusion Matrix")
    plt.show()

# Average accuracy
print(f"\nAverage Test Accuracy: {np.mean(accuracies)}")

# Average Confusion Matrix
avg_conf_matrix = np.mean(conf_matrices, axis=0)
print("\nAverage Confusion Matrix:")
print(avg_conf_matrix)
# Define class labels for visualization
class_labels = [str(i) for i in range(10)]

# Function to plot confusion matrix
def plot_confusion_matrix(conf_matrix):
    plt.figure(figsize=(8, 6))
    sns.heatmap(conf_matrix.astype(int), annot=True, cmap="Blues", xticklabels=class_labels, yticklabels=class_labels, fmt='d')
    plt.xlabel("Predicted")
    plt.ylabel("True")
    plt.title("Confusion Matrix")
    plt.show()

# Plot average confusion matrix
plot_confusion_matrix(avg_conf_matrix)